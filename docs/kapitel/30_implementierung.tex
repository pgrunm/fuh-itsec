\section{Implementierungsphase}

\subsection{Auswahl und Installation der einzusetzenden Software}

\subsubsection{Auswahl eines geeigneten Webserver}

Zur Auswahl eines Webservers muss dieser mindestens die folgenden Anforderungen erfüllen:

\begin{itemize}
    \item Unterstützung für die vom \ac{BSI} empfohlenen \ac{TLS} Versionen 1.2 und 1.3\footcite[Vgl.][S. 6 ff., S. 13 ff.]{bsi}.
    \item Support des Let's Encrypt Certbot für die Ausstellung von Webserver Zertifikaten und automatischen Verlängerung.
    \item Möglichkeit zum Einsatz als Reverse Proxy, um Verbindungen für die Python Applikationen zu terminieren.
    \item Idealerweise gehärtet ab Werk oder Unterstützung zur einfachen Härtung der Konfiguration.
    \item Verfügbarkeit einer hochwertigen Dokumentation.
\end{itemize}

% Allgemeiner Überblick
Zur Auswahl stehen verschiedenste Webserver wie z. B. Apache2, Nginx sowie Caddy. Sämtliche dieser Webserver stehen als quelloffene Software zur Verfügung.

% Überblick Caddy
Caddy unterstützt als einziger der genannten Webserver nicht den Certbot für die automatische Ausstellung von Webserver Zertifikaten und bringt eine eigene Lösung mit. Caddy unterstützt ab Werk \ac{TLS} 1.2 und 1.3, arbeitet als Reverse Proxy und das jüngste Webserver Projekt, welches auf der Programmiersprache Go basiert.

% Apache
Der Webserver Apache2 hingegen existiert bereits seit dem Jahr 1995 und ist hauptsächlich in der Programmiersprache C programmiert. Apache wird von Certbot vollständig unterstützt und kann ebenfalls als Reverse Proxy genutzt werden.

% Nginx
Nginx ist von allen drei Webserver der am meisten verbreitete und kommt auch im Cloud Umfeld z. B. als Ingress Controller für Kubernetes vor. Nginx ist ebenfalls in C programmiert und unterstützt die geforderten \ac{TLS} Versionen und verfügt über eine hochwertige Dokumentation sowie Unterstützung des Certbot.

% Finale Bemerkungen
Sämtliche Webserver verfügen über eine hochwertige Dokumentation und unterstützen die geforderten Anforderungen. Aufgrund der weiten Verbreitung und Tools zur Härtung setzen für auf Nginx als Reverse Proxy.

% Implementierung und Härtung
Die eigentliche Installation des Webservers erfolgt über das im Anhang dargestellte Ansible Playbook (siehe \autoref{listing:ansible_playbook}).

% Härtung
Bei der Härtung sind sowohl die Anforderungen hinsichtlich der kryptografischen Verfahren zu beachten als auch die eigentliche Härtung des Webservers, da dieser von Außen erreichbar ist.

% SSL Config:
% https://ssl-config.mozilla.org/#server=nginx&version=1.17.7&config=intermediate&openssl=1.1.1k&guideline=5.7

% Nginx Server config:
% https://www.digitalocean.com/community/tools/nginx?domains.0.server.domain=messages.fernuni&domains.0.php.php=false&domains.0.reverseProxy.reverseProxy=true&domains.1.server.domain=hello.fernuni&domains.1.php.php=false&domains.1.reverseProxy.reverseProxy=true&domains.1.reverseProxy.proxyPass=http%3A%2F%2F127.0.0.1%3A3001&domains.1.routing.root=false&global.app.lang=de


\begin{listing}[ht]
    \nginxcode[firstline=19, lastline=23]{code/nginx/sites-enabled/hello.fernuni.conf}
    \caption{\enquote{hello.fernuni} Nginx Konfiguration}
    \label{listing:nginx_config_hello}
\end{listing}

Der relevante Teil der Nginx Konfiguration für das Reverse Proxying wird in \autoref{listing:nginx_config_hello} dargestellt. Diese Konfiguration sorgt dafür, dass beim Aufruf der Domain \url{https://hello.fernuni} die eingehende Anfrage auf den auf Localhost lauschenden Docker Container auf den \ac{TCP} Port 3001 weitergeleitet wird. Ein identisches Verfahren wird für die Domain \url{https://messages.fernuni} angewendet. Der Einsatz eines Reverse Proxys ermöglicht die TLS Terminierung und sorgt dafür, dass ein Webserver Zertifikat lediglich im Webserver einzurichten ist. Dies verhindert jedoch eine vollständige Ende zu Ende Verschlüsselung. Die vollständige Konfiguration des Nginx ist im Anhang in \autoref{kap:nginx} ersichtlich.

\subsubsection{Aufsetzen einer Datenbank auf Ubuntu}

Die Webseite \enquote{messages.fernuni} erfordert eine Datenbank. Zur Erfüllung dieser Aufgabe wird eine MySQL-Datenbank aufgesetzt. Dabei werden die erforderlichen Installationsschritte für MySQL, Python-Pakete und die Konfiguration der Datenbank beschrieben und durchgeführt.
Die Installation von MySQL erfolgt über den Paketmanager von Ubuntu. Zunächst wird der MySQL-Server installiert, gefolgt von den erforderlichen Python-Paketen für die Datenbankverbindung. Die benötigten Befehle sind folgende:

\begin{minted}{shell}
    sudo apt install mysql-server python3-pip libmariadb-dev
    sudo pip install mysql-connector mysql-connector-python mariadb
\end{minted}

Nach der Installation kann der MySQL-Server mit folgendem Befehl gestartet werden:

\mint{shell}|sudo service mysql start|

Der Status des MySQL-Servers kann mit folgendem Befehl abgerufen werden:

\mint{shell}|sudo service mysql status|

Nachdem der MySQL-Server gestartet ist, wird eine Datenbank und ein Benutzerkonto auf dem MySQL-Server eingerichtet. Die benötigten Informationen für das Erstellen der Datenbank und des Benutzers werden dem Quellcode der \enquote{messages.fernuni.py} entnommen.
Um eine Datenbank zu erstellen und einen Benutzer anzulegen, wird der \verb+MySQL-Client+ verwendet. Dieser kann mit folgendem Befehl aufgerufen werden:
\mint{shell}|sudo mysql -u root|

Anschließend befinden wir uns in der MySQL-Shell. Hier führen wir die folgenden Befehle aus, um die Datenbank und den Benutzer anzulegen:

\begin{minted}{sql}
    CREATE DATABASE messages;
    CREATE USER 'testuser'@'localhost' IDENTIFIED BY '58tqxEJxqf123';
    GRANT ALL PRIVILEGES ON messages.* TO 'testuser'@'localhost';
\end{minted}

Um eine Tabelle in der Datenbank zu erstellen, verwenden wir erneut die \verb+MySQL Shell+.
Als Erstes wechseln wir zur Datenbank \enquote{messages} und erstellen dort die Tabelle \enquote{messagestorage} mit der Spalte \enquote{timestamp}:

\begin{minted}{sql}
    USE messages;
    CREATE TABLE messagestorage (message TEXT);
    ALTER TABLE messagestorage ADD COLUMN timestamp TIMESTAMP;
\end{minted}

Falls erforderlich, kann der MySQL-Server mit dem folgenden Befehl neu gestartet werden:

\mint{shell}|sudo service mysql restart|

Nun ist die Datenbank, die für \enquote{messages.fernuni} erforderlich ist, aufgesetzt und die Funktionalität der Webseite gewährleistet.

Erstellen eines automatischen Backups der MySQL-Datenbank.

Das automatische Backup gewährleistet den Schutz wichtiger Daten und ermöglicht die Wiederherstellung im Falle eines Datenverlusts oder eines Systemfehlers. Die folgenden Schritte erläutern die Einrichtung des automatischen Backups für unsere Datenbank.
Erstellen einer Skriptdatei für das Backup.
Durch das Erstellen einer Skriptdatei können wir den Backup-Prozess automatisieren und die Ausführungsschritte zentralisieren.
Im Verzeichnis \enquote{/etc/mysql} erstellt man eine Skriptdatei namens \verb+mysql_backup.sh+ mit dem folgenden Inhalt:

\begin{minted}[breaklines=true]{shell}
    #!/bin/bash
    sudo mysqldump -u root messages > /etc/mysql/backup/backup_messages.sql
\end{minted}

Dieses Skript verwendet den Befehl \enquote{mysqldump}, um eine Sicherungskopie der Datenbank \enquote{messages} zu erstellen. 
Die Backup-Datei wird im Verzeichnis /etc/mysql/backup/ mit dem Namen \verb+backup_messages.sql+ gespeichert.

Ausführbarkeit der Skriptdatei gewährleisten

Um die Skriptdatei ausführbar zu machen, gibt man den folgenden Befehl ein:
\begin{verbatim} sudo chmod +x mysql_backup.sh \end{verbatim}
Dadurch wird die Ausführungsberechtigung für die Skriptdatei aktiviert.
Ausführen des Skripts im Terminal, um sicherzustellen, dass es ordnungsgemäß funktioniert:
\mint{shell}|sudo ./mysql_backup.sh|

Einrichten eines regelmäßigen automatischen Updates.

Dazu gibt man den folgenden Befehl ein, um den Crontab-Editor zu öffnen:
\mint{shell}|sudo crontab -e|
Die Verwendung des Crontab-Dienstes ermöglicht es uns, den \verb+Backup-Job+ regelmäßig auszuführen. Durch das Hinzufügen einer Zeile zur Crontab geben wir an, wann und wie oft das Backup-Skript ausgeführt werden soll. 

\begin{verbatim}0 18 * * * /etc/mysql/mysql_backup.sh\end{verbatim}

Diese Zeile gibt die gewünschte Zeit für das Backup an. Hier wird das Backup Skript täglich um 18:00 Uhr ausgeführt.

\subsubsection{Containerisierung der bereitgestellten Programme}

Eine der gestellten Anforderungen der \enquote{Fernuni Inc.} stellt die Containerisierung der in Python implementierten Programme \enquote{hello.fernuni.py} und \enquote{messages.fernuni.py} dar.

Bei Python handelt es sich um eine interpretierte Programmiersprache, sodass eine Laufzeitumgebung zur Ausführung erforderlich ist. Diese muss zusätzlich mit in das Container Image installiert werden, damit das Programm lauffähig ist.

Eine Überlegung zur Härtung der Docker Images wäre die Verwendung eines sogenannten \enquote{Distroless Image}, dass ohne ein Betriebssystem bereitgestellt wird. Allerdings wird der Einsatz eines solchen Images für Python im Produktivbetrieb bislang abgeraten, sodass dies im Kritis-Umfeld nicht möglich ist.

% Kompilierung erwähnen
Eine Idee der Autoren, stellte die Kompilierung des vorhandenen Quellcodes in eine native ausführbare Datei dar, sodass lediglich diese Datei in einen Distroless Image zu kopieren wäre. Einige Versuche mit dem experimenten Compiler \href[]{https://github.com/exaloop/codon}{Codon} schlugen leider fehl, aufgrund fehlender Unterstützung für weitere Module wie beispielsweise Flask. Leider existiert bislang kein ausgereifter Python Compiler, der dies unterstützt, sodass diese Möglichkeit verworfen wurde.

Stattdessen wird beim Bau des \enquote{Messages} Images auf ein sogenanntes \enquote{Multi-Stage-Build} Verfahren gesetzt. Im Rahmen dieses Prozesses wird zunächst ein Container für die Installation sämtlicher benötigter Pakete und zusätzlicher Software zur Installation gestartet. Im Anschluss werden die benötigten Dateien in ein noch leeres Image kopiert und dort als ausführender User \enquote{App} festgelegt. Dies verhindert, dass der Container mit Root Rechten läuft. Aufgrund dieser weiteren Abhängigkeiten für das Mariadb Modul wird in diesem Fall das größere \enquote{Python Slim} Image als Basis genutzt. Dies enthält alle benötigten Softwarebibliotheken zur Installation.

% TODO: Dockerfile überarbeiten
\begin{minted}[breaklines=true]{docker}
# Build image, used to build everything we need
FROM python:3.11-slim as builder

WORKDIR /usr/src/app

# Look for any new updates, install them and install wget.
RUN apt update && apt install -y wget gcc

# Install Mariadb connector, as it's required.
# Source: https://stackoverflow.com/a/74452637
RUN wget https://dlm.mariadb.com/2862620/Connectors/c/connector-c-3.3.4/mariadb-connector-c-3.3.4-debian-bullseye-amd64.tar.gz -O - | tar -zxf - --strip-components=1 -C /usr

# Create a virtual Python environment
RUN python -m venv /usr/src/app/venv
ENV PATH="/usr/src/app/venv/bin:$PATH"

RUN pip install --upgrade pip; pip install --no-cache-dir flask mariadb

COPY . .

# https://pythonspeed.com/articles/multi-stage-docker-python/
FROM python:3.11-slim

WORKDIR /usr/src/app
COPY --from=builder /usr/src/app /usr/src/app
COPY --from=builder /usr /usr

USER app
ENV PATH="/usr/src/app/venv/bin:$PATH"

# Listen on TCP port 8080
EXPOSE 8080
CMD [ "python", "./messages.fernuni.py" ]
\end{minted}

Für die Bereitstellung des \enquote{Hello} Container Image werden keinerlei externe Abhängigkeiten außer Python benötigt. Deshalb dient die Python Variante des sicherheitsorientierten Alpine Linux als Basis für das Container Image. Dort wird lediglich Flask sowie das Python Skript installiert sowie die Ausführung unter einem nicht Root Benutzer eingerichtet. Weiterhin wird bei der Installation der Python Pakete via Pip wird auf ein Cache Verzichnis verzichtet, damit das finale Image möglichst klein ist.

\subsubsection{Umsetzung der Mandatory Access Control mittels AppArmor}\label{kap:installation_apparmor}

Mittels AppArmor ist die Zuweisung von Profilen zu einer Anwendung möglich. Ein Profil besteht dabei aus Regeln, die z. B. lesenden oder schreibenden Zugriff zu einer Datei oder einem Verzeichnis oder sogar Netzwerkzugang ermöglichen. Im Falle einer Kompromittierung kann AppArmor somit des Gesamtsystem schützen.

Im Fokus der Betrachtung stehen insbesondere Anwendungen mit Netzwerkzugriff, da diese auch aus der Ferne angreifbar sind. Im Falle einer Rechteausweitung mittels Privilege Escalation begrenzt AppArmor den potenziellen Schaden\footcite[Vgl.][]{hutchinsIntelligenceDrivenComputerNetwork}.

Dies betrifft insbesondere die Dienste \ac{SSH}, \ac{HTTP} bzw. \ac{HTTPS} sowie Wireguard. Auf Github existieren mehrere Projekte, die fertige Profile für AppArmor anbieten, insbesondere das \enquote{apparmor.d}-Projekt, welches nach eigenen Angaben etwa 1400 Profile bereitstellt. Dabei werden auch Dienste erfasst, welche unter dem \enquote{root} Benutzer ausgeführt werden und folglich besonders anfällig für eine Rechteausweitung sind.

% Begründen, warum ausgerechnet apparmor.d
Das \enquote{apparmor.d}-Projekt eignet sich am ehesten zur Umsetzung umfassender AppArmor Profile, weil dies sowohl aktiv weiterentwickelt wird als auch über eine umfassende Dokumentation verfügt. Es existieren zwar noch andere Projekt, dies ist nach der Anzahl der Beitragenden sowie Commits am weitesten entwickelt.

% Installation kurz beschreiben
Die konkrete Installation der AppArmor Profile ist im Anhang in \autoref{listing:installation_apparmor} beschrieben. In der Dokumentation des Projekts wird explizit darauf hingewiesen, zunächst die Lauffähigkeit des Systems zuprüfen, bevor der Enforce Mode aktiviert.

% Auf Tests eingehen.
Die Überprüfung möglicher Probleme bei der Durchsetzung der Profile erfolgt über den Befehl \mint{shell}|sudo aa-log|
und zeigt dabei sowohl blockierte als auch erlaubte Aktionen an, wie in der folgenden Ausgabe anhand des Docker Daemons erkennbar ist:

\begin{minted}[breaklines=true]{shell}
vagrant@ubuntu-jammy:~$ sudo aa-log 
ALLOWED dockerd mount /var/lib/docker/check-overlayfs-support2956447284/merged/ info="failed mntpnt match" comm=dockerd fstype=overlay srcname=overlay error=-13
ALLOWED dockerd umount /var/lib/docker/check-overlayfs-support2956447284/merged/ comm=dockerd
\end{minted}

\subsubsection{Konfiguration der lokalen Firewall}


\begin{table}[!ht]
    \centering
    \begin{adjustbox}{width=\textwidth}

    \begin{tabular}{|l|l|l|l|l|l|l|l|l|}
        \hline
            Nr. & Protokoll & Quell-IP & Quell-Port & Ziel-IP & Ziel-Port & Interface & -m State & Aktion \\ \hline
            1 & TCP & Internal & ANY & 192.168.2.80 & 22 & eth0 & NEW,ESTABLISHED & ALLOW \\ \hline
            2 & TCP & ANY & ANY & 192.168.2.80 & 80/443 & eth0 & NEW,ESTABLISHED & ALLOW \\ \hline
            3 & TCP & ANY & ANY & 192.168.2.80 & Wireguard & eth0 & NEW,ESTABLISHED & ALLOW \\ \hline
        \end{tabular}
    \end{adjustbox}
    \caption{Übersicht Firewall Regeln}
    \label{regeln_fw_incoming}
\end{table}
% Tabelle erstellen: \url{https://tableconvert.com/latex-generator}

Eine MySQL Regel entfällt, weil lediglich vom lokalen System Verbindungen hergestellt werden. Andernfalls sollte dies ebenfalls auf nur erforderliche Adressen eingerichtet werden. MySQL lauscht in der Standardeinstellung lediglich auf Localhost und externe Verbindungen sind in der derzeitigen Konfiguration nicht vorgesehen. Dementsprechend ist dies die sicherste Variante zum Schutz des Datenbankservers.

Zugriff via \ac{SSH} ist lediglich aus dem internen Netzwerk (\enquote{Internal}, was hier als Platzhalter dient) gestattet, sodass Zugriff aus dem öffentlichen Internet in Gänze unterbunden werden, wie dies auch das Cyber-Killchain Modell vorsieht.

% TODO: Firewall weiter ergänzen, um z. B. böswillige Adressen zu blockieren.
% https://abuse.ch/#platforms
Das Projekt \href{https://abuse.ch}{Abuse.ch} bietet eine regelmäßig aktualisierte Liste mit bösartigen IP-Adressen an, die in Verbindung mit der Verbreitung von Malware oder Botnets stehen. Folglich bietet es sich an, diese IP-Adressen zusätzlich in der Firewall zu blockieren, um weitere Angriffe einzuschränken.